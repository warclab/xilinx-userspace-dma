From 9f8fcd71763369d3f6185ad9350111f75474d989 Mon Sep 17 00:00:00 2001
From: Ciprian Hegbeli <ciprian.hegbeli@gmail.com>
Date: Tue, 19 Nov 2019 16:20:41 +0200
Subject: [PATCH 1/3] staging: add xilinx axi dma

---
 drivers/staging/Kconfig                     |   2 +
 drivers/staging/Makefile                    |   1 +
 drivers/staging/xlnx_axidma/COPYING         | 340 +++++++++
 drivers/staging/xlnx_axidma/Kconfig         |  10 +
 drivers/staging/xlnx_axidma/Makefile        |  16 +
 drivers/staging/xlnx_axidma/axi_dma.c       | 138 ++++
 drivers/staging/xlnx_axidma/axidma.h        | 128 ++++
 drivers/staging/xlnx_axidma/axidma_chrdev.c | 616 ++++++++++++++++
 drivers/staging/xlnx_axidma/axidma_dma.c    | 748 ++++++++++++++++++++
 drivers/staging/xlnx_axidma/axidma_ioctl.h  | 382 ++++++++++
 drivers/staging/xlnx_axidma/axidma_of.c     | 271 +++++++
 11 files changed, 2652 insertions(+)
 create mode 100644 drivers/staging/xlnx_axidma/COPYING
 create mode 100644 drivers/staging/xlnx_axidma/Kconfig
 create mode 100644 drivers/staging/xlnx_axidma/Makefile
 create mode 100644 drivers/staging/xlnx_axidma/axi_dma.c
 create mode 100644 drivers/staging/xlnx_axidma/axidma.h
 create mode 100644 drivers/staging/xlnx_axidma/axidma_chrdev.c
 create mode 100644 drivers/staging/xlnx_axidma/axidma_dma.c
 create mode 100644 drivers/staging/xlnx_axidma/axidma_ioctl.h
 create mode 100644 drivers/staging/xlnx_axidma/axidma_of.c

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index b66275191c54..ea2fb117fe07 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -96,6 +96,8 @@ source "drivers/staging/fsl-dpaa2/Kconfig"
 
 source "drivers/staging/wilc1000/Kconfig"
 
+source "drivers/staging/xlnx_axidma/Kconfig"
+
 source "drivers/staging/most/Kconfig"
 
 source "drivers/staging/ks7010/Kconfig"
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index 9ee2eff76cde..153e798e945f 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -39,6 +39,7 @@ obj-$(CONFIG_XILINX_FCLK)	+= fclk/
 obj-$(CONFIG_FB_TFT)		+= fbtft/
 obj-$(CONFIG_FSL_DPAA2)		+= fsl-dpaa2/
 obj-$(CONFIG_WILC1000)		+= wilc1000/
+obj-$(CONFIG_XLNX_AXI_DMA)	+= xlnx_axidma/
 obj-$(CONFIG_MOST)		+= most/
 obj-$(CONFIG_KS7010)		+= ks7010/
 obj-$(CONFIG_GREYBUS)		+= greybus/
diff --git a/drivers/staging/xlnx_axidma/COPYING b/drivers/staging/xlnx_axidma/COPYING
new file mode 100644
index 000000000000..6d45519c8c6c
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/COPYING
@@ -0,0 +1,340 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff --git a/drivers/staging/xlnx_axidma/Kconfig b/drivers/staging/xlnx_axidma/Kconfig
new file mode 100644
index 000000000000..606d49654961
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/Kconfig
@@ -0,0 +1,10 @@
+config XLNX_AXI_DMA
+	tristate "Xilinx Axi DMA high level driver"
+	depends on CMA && DMA_CMA && XILINX_DMA && XILINX_DMA_ENGINES && DMA_SHARED_BUFFER
+	
+	help
+	  This module adds support to an additional layer to the XILINX 
+	  DMA driver. The purpose of this software stack is to allow userspace 
+	  Linux applications to interact with hardware on the FPGA fabric.
+	  Additonally it enables zero-copy capabilites.
+
diff --git a/drivers/staging/xlnx_axidma/Makefile b/drivers/staging/xlnx_axidma/Makefile
new file mode 100644
index 000000000000..d4e1253c1fe7
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/Makefile
@@ -0,0 +1,16 @@
+DRIVER_NAME = xilinx-axidma
+$(DRIVER_NAME)-objs = axi_dma.o axidma_chrdev.o axidma_dma.o axidma_of.o
+obj-m := $(DRIVER_NAME).o
+
+SRC := $(shell pwd)
+
+all:
+	$(MAKE) -C $(KERNEL_SRC) M=$(SRC)
+
+modules_install:
+	$(MAKE) -C $(KERNEL_SRC) M=$(SRC) modules_install
+
+clean:
+	rm -f *.o *~ core .depend .*.cmd *.ko *.mod.c
+	rm -f Module.markers Module.symvers modules.order
+	rm -rf .tmp_versions Modules.symvers
diff --git a/drivers/staging/xlnx_axidma/axi_dma.c b/drivers/staging/xlnx_axidma/axi_dma.c
new file mode 100644
index 000000000000..4bbb09a9dd84
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axi_dma.c
@@ -0,0 +1,138 @@
+/**
+ * @file axi_dma.c
+ * @date Saturday, November 14, 2015 at 11:20:00 AM EST
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This file contains the top level functions for AXI DMA module.
+ *
+ * @bug No known bugs.
+ **/
+
+// Kernel dependencies
+#include <linux/module.h>           // Module init and exit macros
+#include <linux/moduleparam.h>      // Module param macro
+#include <linux/slab.h>             // Allocation functions
+#include <linux/stat.h>             // Module parameter permission values
+#include <linux/platform_device.h>  // Platform device definitions
+#include <linux/of_address.h>
+
+// Local dependencies
+#include "axidma.h"                 // Internal definitions
+
+/*----------------------------------------------------------------------------
+ * Module Parameters
+ *----------------------------------------------------------------------------*/
+
+// The name to use for the character device. This is "axidma" by default.
+static char *chrdev_name = CHRDEV_NAME;
+module_param(chrdev_name, charp, S_IRUGO);
+
+// The minor number to use for the character device. 0 by default.
+static int minor_num = MINOR_NUMBER;
+module_param(minor_num, int, S_IRUGO);
+
+/*----------------------------------------------------------------------------
+ * Platform Device Functions
+ *----------------------------------------------------------------------------*/
+
+static int axidma_probe(struct platform_device *pdev)
+{
+    int rc;
+    struct axidma_device *axidma_dev;
+
+    // Allocate a AXI DMA device structure to hold metadata about the DMA
+    axidma_dev = kmalloc(sizeof(*axidma_dev), GFP_KERNEL);
+    if (axidma_dev == NULL) {
+        axidma_err("Unable to allocate the AXI DMA device structure.\n");
+        return -ENOMEM;
+    }
+    axidma_dev->pdev = pdev;
+
+    // Initialize the DMA interface
+    rc = axidma_dma_init(pdev, axidma_dev);
+    if (rc < 0) {
+        goto free_axidma_dev;
+    }
+
+    // Assign the character device name, minor number, and number of devices
+    axidma_dev->chrdev_name = chrdev_name;
+    axidma_dev->minor_num = minor_num;
+    axidma_dev->num_devices = NUM_DEVICES;
+
+    // Initialize the character device for the module.
+    rc = axidma_chrdev_init(axidma_dev);
+    if (rc < 0) {
+        goto destroy_dma_dev;
+    }
+
+    // Set the private data in the device to the AXI DMA device structure
+    dev_set_drvdata(&pdev->dev, axidma_dev);
+    return 0;
+
+destroy_dma_dev:
+    axidma_dma_exit(axidma_dev);
+free_axidma_dev:
+    kfree(axidma_dev);
+    return -ENOSYS;
+}
+
+static int axidma_remove(struct platform_device *pdev)
+{
+    struct axidma_device *axidma_dev;
+
+    // Get the AXI DMA device structure from the device's private data
+    axidma_dev = dev_get_drvdata(&pdev->dev);
+
+    // Cleanup the character device structures
+    axidma_chrdev_exit(axidma_dev);
+
+    // Cleanup the DMA structures
+    axidma_dma_exit(axidma_dev);
+
+    // Free the device structure
+    kfree(axidma_dev);
+    return 0;
+}
+
+static const struct of_device_id axidma_compatible_of_ids[] = {
+    { .compatible = "xlnx,axidma-chrdev", },
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, axidma_compatible_of_ids);
+
+static struct platform_driver axidma_driver = {
+    .driver = {
+        .name = MODULE_NAME,
+        .owner = THIS_MODULE,
+        .of_match_table = axidma_compatible_of_ids,
+    },
+    .probe = axidma_probe,
+    .remove = axidma_remove,
+};
+
+/*----------------------------------------------------------------------------
+ * Module Initialization and Exit
+ *----------------------------------------------------------------------------*/
+
+static int __init axidma_init(void)
+{
+    return platform_driver_register(&axidma_driver);
+}
+
+static void __exit axidma_exit(void)
+{
+    return platform_driver_unregister(&axidma_driver);
+}
+
+module_init(axidma_init);
+module_exit(axidma_exit);
+
+MODULE_AUTHOR("Brandon Perez");
+MODULE_AUTHOR("Jared Choi");
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0");
+MODULE_DESCRIPTION("Module to provide a userspace interface for transferring "
+                   "data from the processor to the logic fabric via AXI DMA.");
diff --git a/drivers/staging/xlnx_axidma/axidma.h b/drivers/staging/xlnx_axidma/axidma.h
new file mode 100644
index 000000000000..d322a239f2fd
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axidma.h
@@ -0,0 +1,128 @@
+/**
+ * @file axidma.h
+ * @date Saturday, November 14, 2015 at 01:41:02 PM EST
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This file contains the internal definitions and structures for AXI DMA module
+ *
+ * @bug No known bugs.
+ **/
+
+#ifndef AXIDMA_H_
+#define AXIDMA_H_
+
+// Kernel dependencies
+#include <linux/list.h>         // Linked list definitions and functions
+#include <linux/kernel.h>           // Contains the definition for printk
+#include <linux/device.h>           // Definitions for class and device structs
+#include <linux/cdev.h>             // Definitions for character device structs
+#include <linux/signal.h>           // Definition of signal numbers
+#include <linux/dmaengine.h>        // Definitions for DMA structures and types
+#include <linux/platform_device.h>  // Defintions for a platform device
+
+// Local dependencies
+#include "axidma_ioctl.h"           // IOCTL argument structures
+
+/*----------------------------------------------------------------------------
+ * Module Definitions
+ *----------------------------------------------------------------------------*/
+
+#define MODULE_NAME                 "axidma"
+
+// Truncates the full __FILE__ path, only displaying the basename
+#define __FILENAME__ \
+    (strrchr(__FILE__, '/') ? strrchr(__FILE__, '/') + 1 : __FILE__)
+
+// Convenient macros for printing out messages to the kernel log buffer
+#define axidma_err(fmt, ...) \
+    printk(KERN_ERR MODULE_NAME ": %s: %s: %d: " fmt, __FILENAME__, __func__, \
+           __LINE__, ## __VA_ARGS__)
+#define axidma_info(fmt, ...) \
+    printk(KERN_INFO MODULE_NAME ": %s: %s: %d: " fmt, __FILENAME__, __func__, \
+            __LINE__, ## __VA_ARGS__)
+
+// Forward declaration of the callback data structure for DMA
+struct axidma_cb_data;
+
+// All of the meta-data needed for an axidma device
+struct axidma_device {
+    int num_devices;                // The number of devices
+    unsigned int minor_num;         // The minor number of the device
+    dev_t dev_num;                  // The device number of the device
+    char *chrdev_name;              // The name of the character device
+    struct device *device;          // Device structure for the char device
+    struct class *dev_class;        // The device class for the chardevice
+    struct cdev chrdev;             // The character device structure
+
+    int num_dma_tx_chans;           // The number of transmit DMA channels
+    int num_dma_rx_chans;           // The number of receive DMA channels
+    int num_vdma_tx_chans;          // The number of transmit VDMA channels
+    int num_vdma_rx_chans;          // The number of receive  VDMA channels
+    int num_chans;                  // The total number of DMA channels
+    int notify_signal;              // Signal used to notify transfer completion
+    struct platform_device *pdev;   // The platofrm device from the device tree
+    struct axidma_cb_data *cb_data; // The callback data for each channel
+    struct axidma_chan *channels;   // All available channels
+    struct list_head dmabuf_list;   // List of allocated DMA buffers
+    struct list_head external_dmabufs;  // Buffers allocated in other drivers
+};
+
+/*----------------------------------------------------------------------------
+ * Character Device Definitions
+ *----------------------------------------------------------------------------*/
+
+// Default name of the character of the device
+#define CHRDEV_NAME                 AXIDMA_DEV_NAME
+// Default minor number for the device
+#define MINOR_NUMBER                0
+// The default number of character devices for DMA
+#define NUM_DEVICES                 1
+
+// Function prototypes
+int axidma_chrdev_init(struct axidma_device *dev);
+void axidma_chrdev_exit(struct axidma_device *dev);
+
+/*----------------------------------------------------------------------------
+ * DMA Device Definitions
+ *----------------------------------------------------------------------------*/
+
+// Checks that the given integer is a valid notification signal for DMA
+#define VALID_NOTIFY_SIGNAL(signal) \
+    (SIGRTMIN <= (signal) && (signal) <= SIGRTMAX)
+
+// Function Prototypes
+int axidma_dma_init(struct platform_device *pdev, struct axidma_device *dev);
+void axidma_dma_exit(struct axidma_device *dev);
+void axidma_get_num_channels(struct axidma_device *dev,
+                             struct axidma_num_channels *num_chans);
+void axidma_get_channel_info(struct axidma_device *dev,
+                             struct axidma_channel_info *chan_info);
+int axidma_set_signal(struct axidma_device *dev, int signal);
+int axidma_read_transfer(struct axidma_device *dev,
+                          struct axidma_transaction *trans);
+int axidma_write_transfer(struct axidma_device *dev,
+                          struct axidma_transaction *trans);
+int axidma_rw_transfer(struct axidma_device *dev,
+                       struct axidma_inout_transaction *trans);
+int axidma_video_transfer(struct axidma_device *dev,
+                          struct axidma_video_transaction *trans,
+                          enum axidma_dir dir);
+int axidma_stop_channel(struct axidma_device *dev, struct axidma_chan *chan);
+dma_addr_t axidma_uservirt_to_dma(struct axidma_device *dev, void *user_addr,
+                                  size_t size);
+
+/*----------------------------------------------------------------------------
+ * Device Tree Definitions
+ *----------------------------------------------------------------------------*/
+
+// Macro for printing out an error message related to a device tree node
+#define axidma_node_err(node, fmt, ...) \
+    axidma_err("Device tree node %s: " fmt, node->name, ##__VA_ARGS__)
+
+// Function Prototypes
+int axidma_of_num_channels(struct platform_device *pdev);
+int axidma_of_parse_dma_nodes(struct platform_device *pdev,
+                              struct axidma_device *dev);
+
+#endif /* AXIDMA_H_ */
diff --git a/drivers/staging/xlnx_axidma/axidma_chrdev.c b/drivers/staging/xlnx_axidma/axidma_chrdev.c
new file mode 100644
index 000000000000..f99639ea5a8b
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axidma_chrdev.c
@@ -0,0 +1,616 @@
+/**
+ * @file axidma_chrdev.c
+ * @date Saturday, November 14, 2015 at 12:03:13 PM EST
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This file contains the implementation of the character device for the AXI DMA
+ * module.
+ *
+ * @bug No known bugs.
+ **/
+
+// Kernel dependencies
+#include <linux/list.h>         // Linked list definitions and functions
+#include <linux/sched.h>        // `Current` global variable for current task
+#include <linux/device.h>       // Device and class creation functions
+#include <linux/cdev.h>         // Character device functions
+#include <linux/ioctl.h>        // IOCTL macros and definitions
+#include <linux/fs.h>           // File operations and file types
+#include <linux/mm.h>           // Memory types and remapping functions
+#include <linux/uaccess.h>      // Userspace memory access functions
+#include <linux/slab.h>         // Kernel allocation functions
+#include <linux/errno.h>        // Linux error codes
+#include <linux/of_device.h>    // Device tree device related functions
+
+#include <linux/dma-buf.h>      // DMA shared buffers interface
+#include <linux/scatterlist.h>  // Scatter-gather table definitions
+
+// Local dependencies
+#include "axidma.h"             // Local definitions
+#include "axidma_ioctl.h"       // IOCTL interface for the device
+
+/*----------------------------------------------------------------------------
+ * Internal Definitions
+ *----------------------------------------------------------------------------*/
+
+// TODO: Maybe this can be improved?
+static struct axidma_device *axidma_dev;
+
+// A structure that represents a DMA buffer allocation
+struct axidma_dma_allocation {
+    size_t size;                // Size of the buffer
+    void *user_addr;            // User virtual address of the buffer
+    void *kern_addr;            // Kernel virtual address of the buffer
+    dma_addr_t dma_addr;        // DMA bus address of the buffer
+    struct list_head list;      // List node pointers for allocation list
+};
+
+/* A structure that represents a DMA buffer allocation imported from another
+ * driver in the kernel, through the DMA buffer sharing interface. */
+struct axidma_external_allocation {
+    int fd;                                 // File descritpor for buffer share
+    struct dma_buf *dma_buf;                // Structure representing the buffer
+    struct dma_buf_attachment *dma_attach;  // Structre represnting attachment
+    size_t size;                            // Total size of the buffer
+    void *user_addr;                        // Buffer's user virtual address
+    struct sg_table *sg_table;              // DMA scatter-gather table
+    struct list_head list;                  // Node pointers for the list
+};
+
+/*----------------------------------------------------------------------------
+ * VMA Operations
+ *----------------------------------------------------------------------------*/
+
+static bool valid_dma_request(void *dma_start, size_t dma_size, void *user_addr,
+                              size_t user_size)
+{
+    return dma_start <= user_addr &&
+           (char *)user_addr + user_size <= (char *)dma_start + dma_size;
+}
+
+/* Converts the given user space virtual address to a DMA address. If the
+ * conversion is unsuccessful, then (dma_addr_t)NULL is returned. */
+dma_addr_t axidma_uservirt_to_dma(struct axidma_device *dev, void *user_addr,
+                                  size_t size)
+{
+    bool valid;
+    dma_addr_t offset;
+    struct list_head *iter;
+    struct axidma_dma_allocation *dma_alloc;
+    struct axidma_external_allocation *dma_ext_alloc;
+
+    // First iterate over DMA buffers allocated by this driver
+    list_for_each(iter, &dev->dmabuf_list)
+    {
+        dma_alloc = container_of(iter, struct axidma_dma_allocation, list);
+        valid = valid_dma_request(dma_alloc->user_addr, dma_alloc->size,
+                                  user_addr, size);
+        if (valid) {
+            offset = (dma_addr_t)(user_addr - dma_alloc->user_addr);
+            return dma_alloc->dma_addr + offset;
+        }
+    }
+
+    // Otherwise, iterate over the DMA buffers allocated by other drivers
+    list_for_each(iter, &dev->external_dmabufs)
+    {
+        dma_ext_alloc = container_of(iter, struct axidma_external_allocation,
+                                     list);
+        valid = valid_dma_request(dma_ext_alloc->user_addr, dma_ext_alloc->size,
+                                  user_addr, size);
+        if (valid) {
+            offset = (dma_addr_t)(user_addr - dma_ext_alloc->user_addr);
+            return sg_dma_address(&dma_ext_alloc->sg_table->sgl[0]) + offset;
+        }
+    }
+
+    // No matching allocation was found
+    return (dma_addr_t)NULL;
+}
+
+static int axidma_get_external(struct axidma_device *dev,
+                               struct axidma_register_buffer *ext_buf)
+{
+    int rc;
+    struct axidma_external_allocation *dma_alloc;
+
+    // Allocate a structure to store information about the external buffer
+    dma_alloc = kmalloc(sizeof(*dma_alloc), GFP_KERNEL);
+    if (dma_alloc == NULL) {
+        axidma_err("Unable to allocate external DMA allocation structure.\n");
+        return -ENOMEM;
+    }
+
+    // Get the DMA buffer corresponding to the anonymous file descriptor
+    dma_alloc->fd = ext_buf->fd;
+    dma_alloc->dma_buf = dma_buf_get(ext_buf->fd);
+    if (IS_ERR(dma_alloc->dma_buf)) {
+        axidma_err("Unable to find the external DMA buffer.\n");
+        rc = PTR_ERR(dma_alloc->dma_buf);
+        goto free_ext_alloc;
+    }
+
+    // Attach ourselves to the DMA buffer, indicating usage
+    dma_alloc->dma_attach = dma_buf_attach(dma_alloc->dma_buf, dev->device);
+    if (IS_ERR(dma_alloc->dma_attach)) {
+        axidma_err("Unable to attach to the external DMA buffer.\n");
+        rc = PTR_ERR(dma_alloc->dma_attach);
+        goto put_ext_dma;
+    }
+
+    // TODO: Maybe this should only be done on-demand
+    // Map the DMA buffer for the life of our attachment
+    dma_alloc->sg_table = dma_buf_map_attachment(dma_alloc->dma_attach,
+                                                 DMA_BIDIRECTIONAL);
+    if (IS_ERR(dma_alloc->sg_table)) {
+        axidma_err("Unable to map external DMA buffer for usage.\n");
+        rc = PTR_ERR(dma_alloc->sg_table);
+        goto detach_ext_dma;
+    }
+
+    // The allocation is expected to be one contiguous memory region
+    if (dma_alloc->sg_table->nents != 1) {
+        axidma_err("External DMA allocations must a single contiguous region "
+                   "of physical memory.\n");
+        rc = -EINVAL;
+        goto unmap_ext_dma;
+    }
+
+    // Add ourselves the driver's list of external allocations
+    dma_alloc->size = ext_buf->size;
+    dma_alloc->user_addr = ext_buf->user_addr;
+    list_add(&dma_alloc->list, &dev->external_dmabufs);
+    return 0;
+
+unmap_ext_dma:
+    dma_buf_unmap_attachment(dma_alloc->dma_attach, dma_alloc->sg_table,
+                             DMA_BIDIRECTIONAL);
+detach_ext_dma:
+    dma_buf_detach(dma_alloc->dma_buf, dma_alloc->dma_attach);
+put_ext_dma:
+    dma_buf_put(dma_alloc->dma_buf);
+free_ext_alloc:
+    kfree(dma_alloc);
+    return rc;
+}
+
+static int axidma_put_external(struct axidma_device *dev, void *user_addr)
+{
+    void *end_user_addr;
+    struct list_head *iter;
+    struct axidma_external_allocation *dma_alloc;
+
+    // Find the allocation corresponding to the user address
+    list_for_each(iter, &dev->external_dmabufs)
+    {
+        dma_alloc = container_of(iter, struct axidma_external_allocation, list);
+        end_user_addr = (char *)dma_alloc->user_addr + dma_alloc->size;
+
+        if (dma_alloc->user_addr <= user_addr && user_addr <= end_user_addr) {
+            // Unmap the buffer, and detach ourselves from it
+            dma_buf_unmap_attachment(dma_alloc->dma_attach,
+                    dma_alloc->sg_table, DMA_BIDIRECTIONAL);
+            dma_buf_detach(dma_alloc->dma_buf, dma_alloc->dma_attach);
+            dma_buf_put(dma_alloc->dma_buf);
+
+            // Free the allocation structure
+            kfree(dma_alloc);
+            return 0;
+        }
+    }
+
+    return -ENOENT;
+}
+
+static void axidma_vma_close(struct vm_area_struct *vma)
+{
+    struct axidma_device *dev;
+    struct axidma_dma_allocation *dma_alloc;
+
+    // Get the AXI DMA allocation data and free the DMA buffer
+    dev = axidma_dev;
+    dma_alloc = vma->vm_private_data;
+    dma_free_coherent(&dev->pdev->dev, dma_alloc->size, dma_alloc->kern_addr,
+                      dma_alloc->dma_addr);
+
+    // Remove the allocation from the list, and free the structure
+    list_del(&dma_alloc->list);
+    kfree(dma_alloc);
+
+    return;
+}
+
+// The VMA operations for the AXI DMA device
+static const struct vm_operations_struct axidma_vm_ops = {
+    .close = axidma_vma_close,
+};
+
+/*----------------------------------------------------------------------------
+ * File Operations
+ *----------------------------------------------------------------------------*/
+
+static int axidma_open(struct inode *inode, struct file *file)
+{
+    // Only the root user can open this device, and it must be exclusive
+    if (!capable(CAP_SYS_ADMIN)) {
+        axidma_err("Only root can open this device.");
+        return -EACCES;
+    } else if (!(file->f_flags & O_EXCL)) {
+        axidma_err("O_EXCL must be specified for open()\n");
+        return -EINVAL;
+    }
+
+    // Place the axidma structure in the private data of the file
+    file->private_data = (void *)axidma_dev;
+    return 0;
+}
+
+static int axidma_release(struct inode *inode, struct file *file)
+{
+    file->private_data = NULL;
+    return 0;
+}
+
+static int axidma_mmap(struct file *file, struct vm_area_struct *vma)
+{
+    int rc;
+    struct axidma_device *dev;
+    struct axidma_dma_allocation *dma_alloc;
+
+    // Get the axidma device structure
+    dev = file->private_data;
+
+    // Allocate a structure to store data about the DMA mapping
+    dma_alloc = kmalloc(sizeof(*dma_alloc), GFP_KERNEL);
+    if (dma_alloc == NULL) {
+        axidma_err("Unable to allocate VMA data structure.");
+        rc = -ENOMEM;
+        goto ret;
+    }
+
+    // Set the user virtual address and the size
+    dma_alloc->size = vma->vm_end - vma->vm_start;
+    dma_alloc->user_addr = (void *)vma->vm_start;
+
+    // Configure the DMA device
+    of_dma_configure(&dev->pdev->dev, NULL, true);
+
+    // Allocate the requested region a contiguous and uncached for DMA
+    dma_alloc->kern_addr = dma_alloc_coherent(&dev->pdev->dev, dma_alloc->size,
+                                              &dma_alloc->dma_addr, GFP_KERNEL);
+    if (dma_alloc->kern_addr == NULL) {
+        axidma_err("Unable to allocate contiguous DMA memory region of size "
+                   "%zu.\n", dma_alloc->size);
+        axidma_err("Please make sure that you specified cma=<size> on the "
+                   "kernel command line, and the size is large enough.\n");
+        rc = -ENOMEM;
+        goto free_vma_data;
+    }
+
+    // Map the region into userspace
+    rc = dma_mmap_coherent(&dev->pdev->dev, vma, dma_alloc->kern_addr,
+                           dma_alloc->dma_addr, dma_alloc->size);
+    if (rc < 0) {
+        axidma_err("Unable to remap address %p to userspace address %p, size "
+                   "%zu.\n", dma_alloc->kern_addr, dma_alloc->user_addr,
+                   dma_alloc->size);
+        goto free_dma_region;
+    }
+
+    /* Override the VMA close with our call, so that we can free the DMA region
+     * when the memory region is closed. Pass in the data to do so. */
+    vma->vm_ops = &axidma_vm_ops;
+    vma->vm_private_data = dma_alloc;
+
+    // Do not copy this memory region if this process is forked.
+    /* TODO: Figure out the proper way to actually handle multiple processes
+     * referring to the DMA buffer. */
+    vma->vm_flags |= VM_DONTCOPY;
+
+    // Add the allocation to the driver's list of DMA buffers
+    list_add(&dma_alloc->list, &dev->dmabuf_list);
+    return 0;
+
+free_dma_region:
+    dma_free_coherent(&dev->pdev->dev, dma_alloc->size, dma_alloc->kern_addr,
+                      dma_alloc->dma_addr);
+free_vma_data:
+    kfree(dma_alloc);
+ret:
+    return rc;
+}
+
+/* Verifies that the pointer can be read and/or written to with the given size.
+ * The user specifies the mode, either readonly, or not (read-write). */
+static bool axidma_access_ok(const void __user *arg, size_t size, bool readonly)
+{
+    // Note that VERIFY_WRITE implies VERIFY_WRITE, so read-write is handled
+    if (!readonly && !access_ok(VERIFY_WRITE, arg, size)) {
+        axidma_err("Argument address %p, size %zu cannot be written to.\n",
+                   arg, size);
+        return false;
+    } else if (!access_ok(VERIFY_READ, arg, size)) {
+        axidma_err("Argument address %p, size %zu cannot be read from.\n",
+                   arg, size);
+        return false;
+    }
+
+    return true;
+}
+
+static long axidma_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+    long rc;
+    size_t size;
+    void *__user arg_ptr;
+    struct axidma_device *dev;
+    struct axidma_num_channels num_chans;
+    struct axidma_channel_info usr_chans, kern_chans;
+    struct axidma_register_buffer ext_buf;
+    struct axidma_transaction trans;
+    struct axidma_inout_transaction inout_trans;
+    struct axidma_video_transaction video_trans, *__user user_video_trans;
+    struct axidma_chan chan_info;
+
+    // Coerce the arguement as a userspace pointer
+    arg_ptr = (void __user *)arg;
+
+    // Verify that this IOCTL is intended for our device, and is in range
+    if (_IOC_TYPE(cmd) != AXIDMA_IOCTL_MAGIC) {
+        axidma_err("IOCTL command magic number does not match.\n");
+        return -ENOTTY;
+    } else if (_IOC_NR(cmd) >= AXIDMA_NUM_IOCTLS) {
+        axidma_err("IOCTL command is out of range for this device.\n");
+        return -ENOTTY;
+    }
+
+    // Verify the input argument
+    if ((_IOC_DIR(cmd) & _IOC_READ)) {
+        if (!axidma_access_ok(arg_ptr, _IOC_SIZE(cmd), false)) {
+            return -EFAULT;
+        }
+    } else if (_IOC_DIR(cmd) & _IOC_WRITE) {
+        if (!axidma_access_ok(arg_ptr, _IOC_SIZE(cmd), true)) {
+            return -EFAULT;
+        }
+    }
+
+    // Get the axidma device from the file
+    dev = file->private_data;
+
+    // Perform the specified command
+    switch (cmd) {
+        case AXIDMA_GET_NUM_DMA_CHANNELS:
+            axidma_get_num_channels(dev, &num_chans);
+            if (copy_to_user(arg_ptr, &num_chans, sizeof(num_chans)) != 0) {
+                axidma_err("Unable to copy channel info to userspace for "
+                           "AXIDMA_GET_NUM_DMA_CHANNELS.\n");
+                return -EFAULT;
+            }
+            rc = 0;
+            break;
+
+        case AXIDMA_GET_DMA_CHANNELS:
+            if (copy_from_user(&usr_chans, arg_ptr, sizeof(usr_chans)) != 0) {
+                axidma_err("Unable to copy channel buffer address from "
+                           "userspace for AXIDMA_GET_DMA_CHANNELS.\n");
+                return -EFAULT;
+            }
+
+            // Copy the channels array to userspace
+            axidma_get_num_channels(dev, &num_chans);
+            axidma_get_channel_info(dev, &kern_chans);
+            size = num_chans.num_channels * sizeof(kern_chans.channels[0]);
+            if (copy_to_user(usr_chans.channels, kern_chans.channels, size)) {
+                axidma_err("Unable to copy channel ids to userspace for "
+                           "AXIDMA_GET_DMA_CHANNELS.\n");
+                return -EFAULT;
+            }
+
+            rc = 0;
+            break;
+
+        case AXIDMA_SET_DMA_SIGNAL:
+            rc = axidma_set_signal(dev, arg);
+            break;
+
+        case AXIDMA_REGISTER_BUFFER:
+            if (copy_from_user(&ext_buf, arg_ptr, sizeof(ext_buf)) != 0) {
+                axidma_err("Unable to copy external buffer info from userspace "
+                           "for AXIDMA_REGISTER_BUFFER.\n");
+                return -EFAULT;
+            }
+            rc = axidma_get_external(dev, &ext_buf);
+            break;
+
+        case AXIDMA_DMA_READ:
+            if (copy_from_user(&trans, arg_ptr, sizeof(trans)) != 0) {
+                axidma_err("Unable to copy transfer info from userspace for "
+                           "AXIDMA_DMA_READ.\n");
+                return -EFAULT;
+            }
+            rc = axidma_read_transfer(dev, &trans);
+            break;
+
+        case AXIDMA_DMA_WRITE:
+            if (copy_from_user(&trans, arg_ptr, sizeof(trans)) != 0) {
+                axidma_err("Unable to copy transfer info from userspace for "
+                           "AXIDMA_DMA_WRITE.\n");
+                return -EFAULT;
+            }
+            rc = axidma_write_transfer(dev, &trans);
+            break;
+
+        case AXIDMA_DMA_READWRITE:
+            if (copy_from_user(&inout_trans, arg_ptr,
+                               sizeof(inout_trans)) != 0) {
+                axidma_err("Unable to copy transfer info from userspace for "
+                           "AXIDMA_DMA_READWRITE.\n");
+                return -EFAULT;
+            }
+            rc = axidma_rw_transfer(dev, &inout_trans);
+            break;
+
+        case AXIDMA_DMA_VIDEO_READ:
+            if (copy_from_user(&video_trans, arg_ptr,
+                               sizeof(video_trans)) != 0) {
+                axidma_err("Unable to copy transfer info from userspace for "
+                           "AXIDMA_DMA_VIDEO_READ.\n");
+                return -EFAULT;
+            }
+
+            // Allocate a kernel-space array for the frame buffers
+            size = video_trans.num_frame_buffers *
+                   sizeof(video_trans.frame_buffers[0]);
+            video_trans.frame_buffers = kmalloc(size, GFP_KERNEL);
+            if (video_trans.frame_buffers == NULL) {
+                axidma_err("Unable to allocate array for the frame buffers.\n");
+                return -ENOMEM;
+            }
+
+            // Copy the frame buffer array from user space to kernel space
+            user_video_trans = (struct axidma_video_transaction *__user)arg_ptr;
+            if (copy_from_user(video_trans.frame_buffers,
+                        user_video_trans->frame_buffers, size) != 0) {
+                axidma_err("Unable to copy the frame buffer array from "
+                        "userspace for AXIDMA_VIDEO_READ.\n");
+                kfree(video_trans.frame_buffers);
+                return -EFAULT;
+            }
+
+            rc = axidma_video_transfer(dev, &video_trans, AXIDMA_READ);
+            kfree(video_trans.frame_buffers);
+            break;
+
+        case AXIDMA_DMA_VIDEO_WRITE:
+            if (copy_from_user(&video_trans, arg_ptr,
+                               sizeof(video_trans)) != 0) {
+                axidma_err("Unable to copy transfer info from userspace for "
+                           "AXIDMA_VIDEO_WRITE.\n");
+                return -EFAULT;
+            }
+
+            // Allocate a kernel-space array for the frame buffers
+            size = video_trans.num_frame_buffers *
+                   sizeof(video_trans.frame_buffers[0]);
+            video_trans.frame_buffers = kmalloc(size, GFP_KERNEL);
+            if (video_trans.frame_buffers == NULL) {
+                axidma_err("Unable to allocate array for the frame buffers.\n");
+                return -ENOMEM;
+            }
+
+            // Copy the frame buffer array from user space to kernel space
+            user_video_trans = (struct axidma_video_transaction *__user)arg_ptr;
+            if (copy_from_user(video_trans.frame_buffers,
+                        user_video_trans->frame_buffers, size) != 0) {
+                axidma_err("Unable to copy the frame buffer array from "
+                        "userspace for AXIDMA_VIDEO_READ.\n");
+                kfree(video_trans.frame_buffers);
+                return -EFAULT;
+            }
+
+            rc = axidma_video_transfer(dev, &video_trans, AXIDMA_WRITE);
+            kfree(video_trans.frame_buffers);
+            break;
+
+        case AXIDMA_STOP_DMA_CHANNEL:
+            if (copy_from_user(&chan_info, arg_ptr, sizeof(chan_info)) != 0) {
+                axidma_err("Unable to channel info from userspace for "
+                           "AXIDMA_STOP_DMA_CHANNEL.\n");
+            }
+            rc = axidma_stop_channel(dev, &chan_info);
+            break;
+
+        case AXIDMA_UNREGISTER_BUFFER:
+            rc = axidma_put_external(dev, (void *)arg);
+            break;
+
+        // Invalid command (already handled in preamble)
+        default:
+            return -ENOTTY;
+    }
+
+    return rc;
+}
+
+// The file operations for the AXI DMA device
+static const struct file_operations axidma_fops = {
+    .owner = THIS_MODULE,
+    .open = axidma_open,
+    .release = axidma_release,
+    .mmap = axidma_mmap,
+    .unlocked_ioctl = axidma_ioctl,
+};
+
+/*----------------------------------------------------------------------------
+ * Initialization and Cleanup
+ *----------------------------------------------------------------------------*/
+
+int axidma_chrdev_init(struct axidma_device *dev)
+{
+    int rc;
+
+    // Store a global pointer to the axidma device
+    axidma_dev = dev;
+
+    // Allocate a major and minor number region for the character device
+    rc = alloc_chrdev_region(&dev->dev_num, dev->minor_num, dev->num_devices,
+                             dev->chrdev_name);
+    if (rc < 0) {
+        axidma_err("Unable to allocate character device region.\n");
+        goto ret;
+    }
+
+    // Create a device class for our device
+    dev->dev_class = class_create(THIS_MODULE, dev->chrdev_name);
+    if (IS_ERR(dev->dev_class)) {
+        axidma_err("Unable to create a device class.\n");
+        rc = PTR_ERR(dev->dev_class);
+        goto free_chrdev_region;
+    }
+
+    /* Create a device for our module. This will create a file on the
+     * filesystem, under "/dev/dev->chrdev_name". */
+    dev->device = device_create(dev->dev_class, NULL, dev->dev_num, NULL,
+                                dev->chrdev_name);
+    if (IS_ERR(dev->device)) {
+        axidma_err("Unable to create a device.\n");
+        rc = PTR_ERR(dev->device);
+        goto class_cleanup;
+    }
+
+    // Register our character device with the kernel
+    cdev_init(&dev->chrdev, &axidma_fops);
+    rc = cdev_add(&dev->chrdev, dev->dev_num, dev->num_devices);
+    if (rc < 0) {
+        axidma_err("Unable to add a character device.\n");
+        goto device_cleanup;
+    }
+
+    // Initialize the list for DMA mmap'ed allocations
+    INIT_LIST_HEAD(&dev->dmabuf_list);
+    INIT_LIST_HEAD(&dev->external_dmabufs);
+
+    return 0;
+
+device_cleanup:
+    device_destroy(dev->dev_class, dev->dev_num);
+class_cleanup:
+    class_destroy(dev->dev_class);
+free_chrdev_region:
+    unregister_chrdev_region(dev->dev_num, dev->num_devices);
+ret:
+    return rc;
+}
+
+void axidma_chrdev_exit(struct axidma_device *dev)
+{
+    // Cleanup all related character device structures
+    cdev_del(&dev->chrdev);
+    device_destroy(dev->dev_class, dev->dev_num);
+    class_destroy(dev->dev_class);
+    unregister_chrdev_region(dev->dev_num, dev->num_devices);
+
+    return;
+}
diff --git a/drivers/staging/xlnx_axidma/axidma_dma.c b/drivers/staging/xlnx_axidma/axidma_dma.c
new file mode 100644
index 000000000000..4b54de0200ad
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axidma_dma.c
@@ -0,0 +1,748 @@
+/**
+ * @file axidma_dma.c
+ * @date Saturday, November 14, 2015 at 02:28:23 PM EST
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This module contains the interface to the DMA engine for the AXI DMA module.
+ *
+ * @bug No known bugs.
+ **/
+
+// Kernel dependencies
+#include <linux/delay.h>            // Milliseconds to jiffies converstion
+#include <linux/wait.h>             // Completion related functions
+
+/* <linux/signal.h> was moved to <linux/sched/signal.h> in the 4.11 kernel */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,11,0)
+#include <linux/sched.h>            // Send signal to process function
+#else
+#include <linux/sched/signal.h>     // send_sig_info function
+#endif
+
+#include <linux/dmaengine.h>        // DMA types and functions
+#include <linux/slab.h>             // Allocation functions
+#include <linux/errno.h>            // Linux error codes
+#include <linux/platform_device.h>  // Platform device definitions
+#include <linux/device.h>           // Device definitions and functions
+
+/* Between 3.x and 4.x, the path to Xilinx's DMA include file changes. However,
+ * in some 4.x kernels, the path is still the old one from 3.x. The macro is
+ * defined by the Makefile, when specified by the user. */
+#ifndef XILINX_DMA_INCLUDE_PATH_FIXUP
+#include <linux/dma/xilinx_dma.h>   // Xilinx DMA config structures
+#else
+#include <linux/amba/xilinx_dma.h>  // Xilinx DMA config structures
+#endif
+
+// Local dependencies
+#include "axidma.h"                 // Internal definitions
+#include "axidma_ioctl.h"           // IOCTL interface definition and types
+
+/*----------------------------------------------------------------------------
+ * Internal Definitions
+ *----------------------------------------------------------------------------*/
+
+// The default timeout for DMA is 10 seconds
+#define AXIDMA_DMA_TIMEOUT      10000
+
+// A convenient structure to pass between prep and start transfer functions
+struct axidma_transfer {
+    int sg_len;                     // The length of the BD array
+    struct scatterlist *sg_list;    // List of buffer descriptors
+    bool wait;                      // Indicates if we should wait
+    dma_cookie_t cookie;            // The DMA cookie for the transfer
+    struct completion comp;         // A completion to use for waiting
+    enum axidma_dir dir;            // The direction of the transfer
+    enum axidma_type type;          // The type of the transfer (VDMA/DMA)
+    int channel_id;                 // The ID of the channel
+    int notify_signal;              // The signal to use for async transfers
+    struct task_struct *process;    // The process requesting the transfer
+    struct axidma_cb_data *cb_data; // The callback data struct
+
+    // VDMA specific fields (kept as union for extensability)
+    union {
+        struct axidma_video_frame frame;    // Frame information for VDMA
+    };
+};
+
+// The data to pass to the DMA transfer completion callback function
+struct axidma_cb_data {
+    int channel_id;                 // The id of the channel used
+    int notify_signal;              // For async, signal to send
+    struct task_struct *process;    // The process to send the signal to
+    struct completion *comp;        // For sync, the notification to kernel
+};
+
+/*----------------------------------------------------------------------------
+ * Enumeration Conversions
+ *----------------------------------------------------------------------------*/
+
+static char *axidma_dir_to_string(enum axidma_dir dma_dir)
+{
+    BUG_ON(dma_dir != AXIDMA_WRITE && dma_dir != AXIDMA_READ);
+    return (dma_dir == AXIDMA_WRITE) ? "transmit" : "receive";
+}
+
+static char *axidma_type_to_string(enum axidma_type dma_type)
+{
+    BUG_ON(dma_type != AXIDMA_DMA && dma_type != AXIDMA_VDMA);
+    return (dma_type == AXIDMA_DMA) ? "DMA" : "VDMA";
+}
+
+// Convert the AXI DMA direction enumeration to a DMA direction enumeration
+static enum dma_transfer_direction axidma_to_dma_dir(enum axidma_dir dma_dir)
+{
+    BUG_ON(dma_dir != AXIDMA_WRITE && dma_dir != AXIDMA_READ);
+    return (dma_dir == AXIDMA_WRITE) ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;
+}
+
+/*----------------------------------------------------------------------------
+ * DMA Operations Helper Functions
+ *----------------------------------------------------------------------------*/
+
+static int axidma_init_sg_entry(struct axidma_device *dev,
+        struct scatterlist *sg_list, int index, void *buf, size_t buf_len)
+{
+    dma_addr_t dma_addr;
+
+    // Get the DMA address from the user virtual address
+    dma_addr = axidma_uservirt_to_dma(dev, buf, buf_len);
+    if (dma_addr == (dma_addr_t)NULL) {
+        axidma_err("Requested transfer address %p does not fall within a "
+                   "previously allocated DMA buffer.\n", buf);
+        return -EFAULT;
+    }
+
+    // Initialize the scatter-gather table entry
+    sg_dma_address(&sg_list[index]) = dma_addr;
+    sg_dma_len(&sg_list[index]) = buf_len;
+
+    return 0;
+}
+
+static struct axidma_chan *axidma_get_chan(struct axidma_device *dev,
+        int channel_id)
+{
+    int i;
+    struct axidma_chan *chan;
+
+    // Find the channel with the given ID that matches the type and direction
+    for (i = 0; i < dev->num_chans; i++)
+    {
+        chan = &dev->channels[i];
+        if (chan->channel_id == channel_id) {
+            return chan;
+        }
+    }
+
+    return NULL;
+}
+
+static void axidma_dma_callback(void *data)
+{
+    struct axidma_cb_data *cb_data;
+    struct siginfo sig_info;
+
+    /* For synchronous transfers, notify the kernel thread waiting. For
+     * asynchronous transfers, send a signal to userspace if requested. */
+    cb_data = data;
+    if (cb_data->comp != NULL) {
+        complete(cb_data->comp);
+    } else if (VALID_NOTIFY_SIGNAL(cb_data->notify_signal)) {
+        memset(&sig_info, 0, sizeof(sig_info));
+        sig_info.si_signo = cb_data->notify_signal;
+        sig_info.si_code = SI_QUEUE;
+        sig_info.si_int = cb_data->channel_id;
+        send_sig_info(cb_data->notify_signal, &sig_info, cb_data->process);
+    }
+}
+
+// Setup the config structure for VDMA
+static void axidma_setup_vdma_config(struct xilinx_vdma_config *dma_config)
+{
+    memset(dma_config, 0, sizeof(*dma_config));
+    dma_config->frm_dly = 0;            // Number of frames to delay
+    dma_config->gen_lock = 0;           // Genlock, VDMA runs on fsyncs
+    dma_config->master = 0;             // VDMA is the genlock master
+    dma_config->frm_cnt_en = 1;         // Interrupt based on frame count
+    dma_config->park = 0;               // Continuously process all frames
+    dma_config->park_frm = 0;           // Frame to stop (park) at (N/A)
+    dma_config->coalesc = 1;            // Interrupt after one frame completion
+    dma_config->delay = 0;              // Disable the delay counter interrupt
+    dma_config->reset = 0;              // Don't reset the channel
+    dma_config->ext_fsync = 0;          // VDMA handles synchronizes itself
+    return;
+}
+
+static int axidma_prep_transfer(struct axidma_chan *axidma_chan,
+                                struct axidma_transfer *dma_tfr)
+{
+    struct dma_chan *chan;
+    struct dma_device *dma_dev;
+    struct dma_async_tx_descriptor *dma_txnd;
+    struct completion *dma_comp;
+    struct xilinx_vdma_config vdma_config;
+    struct axidma_cb_data *cb_data;
+    struct dma_interleaved_template dma_template;
+    enum dma_transfer_direction dma_dir;
+    enum dma_ctrl_flags dma_flags;
+    struct scatterlist *sg_list;
+    int sg_len;
+    dma_cookie_t dma_cookie;
+    char *direction, *type;
+    int rc;
+
+    // Get the fields from the structures
+    chan = axidma_chan->chan;
+    dma_comp = &dma_tfr->comp;
+    dma_dir = axidma_to_dma_dir(dma_tfr->dir);
+    dma_dev = chan->device;
+    sg_list = dma_tfr->sg_list;
+    sg_len = dma_tfr->sg_len;
+    direction = axidma_dir_to_string(dma_tfr->dir);
+    type = axidma_type_to_string(dma_tfr->type);
+    cb_data = dma_tfr->cb_data;
+
+    /* For VDMA transfers, we configure the channel, then prepare an interlaved
+     * transfer. For DMA, we simply prepare a slave scatter-gather transfer. */
+    dma_flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;
+    if (dma_tfr->type == AXIDMA_DMA) {
+        dma_txnd = dmaengine_prep_slave_sg(chan, sg_list, sg_len, dma_dir,
+                                           dma_flags);
+    } else {
+        axidma_setup_vdma_config(&vdma_config);
+        rc = xilinx_vdma_channel_set_config(chan, &vdma_config);
+        if (rc < 0) {
+            axidma_err("Unable to set the config for channel.\n");
+            goto stop_dma;
+        }
+
+        memset(&dma_template, 0, sizeof(dma_template));
+        dma_template.dst_start = sg_dma_address(&sg_list[0]);
+        dma_template.src_start = sg_dma_address(&sg_list[0]);
+        dma_template.dir = dma_dir;
+        dma_template.numf = dma_tfr->frame.height;
+        dma_template.frame_size = 1;
+        dma_template.sgl[0].size = dma_tfr->frame.width *
+                dma_tfr->frame.depth;
+        dma_template.sgl[0].icg = 0;
+        dma_txnd = dmaengine_prep_interleaved_dma(chan, &dma_template,
+                dma_flags);
+    }
+    if (dma_txnd == NULL) {
+        axidma_err("Unable to prepare the dma engine for the %s %s buffer.\n",
+                   type, direction);
+        rc = -EBUSY;
+        goto stop_dma;
+    }
+
+    /* If we're going to wait for this channel, initialize the completion for
+     * the channel, and setup the callback to complete it. */
+    cb_data->channel_id = dma_tfr->channel_id;
+    if (dma_tfr->wait) {
+        cb_data->comp = dma_comp;
+        cb_data->notify_signal = -1;
+        cb_data->process = NULL;
+        init_completion(cb_data->comp);
+        dma_txnd->callback_param = cb_data;
+        dma_txnd->callback = axidma_dma_callback;
+    } else {
+        cb_data->comp = NULL;
+        cb_data->notify_signal = dma_tfr->notify_signal;
+        cb_data->process = dma_tfr->process;
+        dma_txnd->callback_param = cb_data;
+        dma_txnd->callback = axidma_dma_callback;
+    }
+    dma_cookie = dmaengine_submit(dma_txnd);
+    if (dma_submit_error(dma_cookie)) {
+        axidma_err("Unable to submit the %s %s transaction to the engine.\n",
+                   direction, type);
+        rc = -EBUSY;
+        goto stop_dma;
+    }
+
+    // Return the DMA cookie for the transaction
+    dma_tfr->cookie = dma_cookie;
+    return 0;
+
+stop_dma:
+    dmaengine_terminate_all(chan);
+    return rc;
+}
+
+static int axidma_start_transfer(struct axidma_chan *chan,
+                                 struct axidma_transfer *dma_tfr)
+{
+    struct completion *dma_comp;
+    dma_cookie_t dma_cookie;
+    enum dma_status status;
+    char *direction, *type;
+    unsigned long timeout, time_remain;
+    int rc;
+
+    // Get the fields from the structures
+    dma_comp = &dma_tfr->comp;
+    dma_cookie = dma_tfr->cookie;
+    direction = axidma_dir_to_string(dma_tfr->dir);
+    type = axidma_type_to_string(dma_tfr->type);
+
+    // Flush all pending transaction in the dma engine for this channel
+    dma_async_issue_pending(chan->chan);
+
+    // Wait for the completion timeout or the DMA to complete
+    if (dma_tfr->wait) {
+        timeout = msecs_to_jiffies(AXIDMA_DMA_TIMEOUT);
+        time_remain = wait_for_completion_timeout(dma_comp, timeout);
+        status = dma_async_is_tx_complete(chan->chan, dma_cookie, NULL, NULL);
+
+        if (time_remain == 0) {
+            axidma_err("%s %s transaction timed out.\n", type, direction);
+            rc = -ETIME;
+            goto stop_dma;
+        } else if (status != DMA_COMPLETE) {
+            axidma_err("%s %s transaction did not succceed. Status is %d.\n",
+                       type, direction, status);
+            rc = -EBUSY;
+            goto stop_dma;
+        }
+    }
+
+    return 0;
+
+stop_dma:
+    dmaengine_terminate_all(chan->chan);
+    return rc;
+}
+
+/*----------------------------------------------------------------------------
+ * DMA Operations (Public Interface)
+ *----------------------------------------------------------------------------*/
+
+void axidma_get_num_channels(struct axidma_device *dev,
+                             struct axidma_num_channels *num_chans)
+{
+    num_chans->num_channels = dev->num_chans;
+    num_chans->num_dma_tx_channels = dev->num_dma_tx_chans;
+    num_chans->num_dma_rx_channels = dev->num_dma_rx_chans;
+    num_chans->num_vdma_tx_channels = dev->num_vdma_tx_chans;
+    num_chans->num_vdma_rx_channels = dev->num_vdma_rx_chans;
+    return;
+}
+
+void axidma_get_channel_info(struct axidma_device *dev,
+                             struct axidma_channel_info *chan_info)
+{
+    chan_info->channels = dev->channels;
+    return;
+}
+
+int axidma_set_signal(struct axidma_device *dev, int signal)
+{
+    // Verify the signal is a real-time one
+    if (!VALID_NOTIFY_SIGNAL(signal)) {
+        axidma_err("Invalid signal %d requested for DMA notification.\n",
+                   signal);
+        axidma_err("You must specify one of the POSIX real-time signals.\n");
+        return -EINVAL;
+    }
+
+    dev->notify_signal = signal;
+    return 0;
+}
+
+int axidma_read_transfer(struct axidma_device *dev,
+                         struct axidma_transaction *trans)
+{
+    int rc;
+    struct axidma_chan *rx_chan;
+    struct scatterlist sg_list;
+    struct axidma_transfer rx_tfr;
+
+    // Get the channel with the given channel id
+    rx_chan = axidma_get_chan(dev, trans->channel_id);
+    if (rx_chan == NULL || rx_chan->dir != AXIDMA_READ) {
+        axidma_err("Invalid device id %d for DMA receive channel.\n",
+                   trans->channel_id);
+        return -ENODEV;
+    }
+
+    // Setup the scatter-gather list for the transfer (only one entry)
+    sg_init_table(&sg_list, 1);
+    rc = axidma_init_sg_entry(dev, &sg_list, 0, trans->buf,
+                              trans->buf_len);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Setup receive transfer structure for DMA
+    rx_tfr.sg_list = &sg_list;
+    rx_tfr.sg_len = 1;
+    rx_tfr.dir = rx_chan->dir;
+    rx_tfr.type = rx_chan->type;
+    rx_tfr.wait = trans->wait;
+    rx_tfr.channel_id = trans->channel_id;
+    rx_tfr.notify_signal = dev->notify_signal;
+    rx_tfr.process = get_current();
+    rx_tfr.cb_data = &dev->cb_data[trans->channel_id];
+
+    // Prepare the receive transfer
+    rc = axidma_prep_transfer(rx_chan, &rx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Submit the receive transfer, and wait for it to complete
+    rc = axidma_start_transfer(rx_chan, &rx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    return 0;
+}
+
+int axidma_write_transfer(struct axidma_device *dev,
+                          struct axidma_transaction *trans)
+{
+    int rc;
+    struct axidma_chan *tx_chan;
+    struct scatterlist sg_list;
+    struct axidma_transfer tx_tfr;
+
+    // Get the channel with the given id
+    tx_chan = axidma_get_chan(dev, trans->channel_id);
+    if (tx_chan == NULL || tx_chan->dir != AXIDMA_WRITE) {
+        axidma_err("Invalid device id %d for DMA transmit channel.\n",
+                   trans->channel_id);
+        return -ENODEV;
+    }
+
+    // Setup the scatter-gather list for the transfer (only one entry)
+    sg_init_table(&sg_list, 1);
+    rc = axidma_init_sg_entry(dev, &sg_list, 0, trans->buf,
+                              trans->buf_len);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Setup transmit transfer structure for DMA
+    tx_tfr.sg_list = &sg_list;
+    tx_tfr.sg_len = 1;
+    tx_tfr.dir = tx_chan->dir;
+    tx_tfr.type = tx_chan->type;
+    tx_tfr.wait = trans->wait;
+    tx_tfr.channel_id = trans->channel_id;
+    tx_tfr.notify_signal = dev->notify_signal;
+    tx_tfr.process = get_current();
+    tx_tfr.cb_data = &dev->cb_data[trans->channel_id];
+
+    // Prepare the transmit transfer
+    rc = axidma_prep_transfer(tx_chan, &tx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Submit the transmit transfer, and wait for it to complete
+    rc = axidma_start_transfer(tx_chan, &tx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    return 0;
+}
+
+/* Transfers data from the given source buffer out to the AXI DMA device, and
+ * places the data received into the receive buffer. */
+int axidma_rw_transfer(struct axidma_device *dev,
+                       struct axidma_inout_transaction *trans)
+{
+    int rc;
+    struct axidma_chan *tx_chan, *rx_chan;
+    struct scatterlist tx_sg_list, rx_sg_list;
+    struct axidma_transfer tx_tfr, rx_tfr;
+
+    // Get the transmit and receive channels with the given ids.
+    tx_chan = axidma_get_chan(dev, trans->tx_channel_id);
+    if (tx_chan == NULL || tx_chan->dir != AXIDMA_WRITE) {
+        axidma_err("Invalid device id %d for DMA transmit channel.\n",
+                   trans->tx_channel_id);
+        return -ENODEV;
+    }
+
+    rx_chan = axidma_get_chan(dev, trans->rx_channel_id);
+    if (rx_chan == NULL || rx_chan->dir != AXIDMA_READ) {
+        axidma_err("Invalid device id %d for DMA receive channel.\n",
+                   trans->rx_channel_id);
+        return -ENODEV;
+    }
+
+    // Setup the scatter-gather list for the transfers (only one entry)
+    sg_init_table(&tx_sg_list, 1);
+    rc = axidma_init_sg_entry(dev, &tx_sg_list, 0, trans->tx_buf,
+                              trans->tx_buf_len);
+    if (rc < 0) {
+        return rc;
+    }
+    sg_init_table(&rx_sg_list, 1);
+    rc = axidma_init_sg_entry(dev, &rx_sg_list, 0, trans->rx_buf,
+                              trans->rx_buf_len);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Setup receive and trasmit transfer structures for DMA
+    tx_tfr.sg_list = &tx_sg_list,
+    tx_tfr.sg_len = 1,
+    tx_tfr.dir = tx_chan->dir,
+    tx_tfr.type = tx_chan->type,
+    tx_tfr.wait = false,
+    tx_tfr.channel_id = trans->tx_channel_id,
+    tx_tfr.notify_signal = dev->notify_signal,
+    tx_tfr.process = get_current(),
+    tx_tfr.cb_data = &dev->cb_data[trans->tx_channel_id];
+
+    // Add in the frame information for VDMA transfers
+    if (tx_chan->type == AXIDMA_VDMA) {
+        memcpy(&tx_tfr.frame, &trans->tx_frame, sizeof(tx_tfr.frame));
+    }
+
+    rx_tfr.sg_list = &rx_sg_list,
+    rx_tfr.sg_len = 1,
+    rx_tfr.dir = rx_chan->dir,
+    rx_tfr.type = rx_chan->type,
+    rx_tfr.wait = trans->wait,
+    rx_tfr.channel_id = trans->rx_channel_id,
+    rx_tfr.notify_signal = dev->notify_signal,
+    rx_tfr.process = get_current(),
+    rx_tfr.cb_data = &dev->cb_data[trans->rx_channel_id];
+
+    // Add in the frame information for VDMA transfers
+    if (tx_chan->type == AXIDMA_VDMA) {
+        memcpy(&rx_tfr.frame, &trans->rx_frame, sizeof(rx_tfr.frame));
+    }
+
+    // Prep both the receive and transmit transfers
+    rc = axidma_prep_transfer(tx_chan, &tx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+    rc = axidma_prep_transfer(rx_chan, &rx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Submit both transfers to the DMA engine, and wait on the receive transfer
+    rc = axidma_start_transfer(tx_chan, &tx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+    rc = axidma_start_transfer(rx_chan, &rx_tfr);
+    if (rc < 0) {
+        return rc;
+    }
+
+    return 0;
+}
+
+int axidma_video_transfer(struct axidma_device *dev,
+                          struct axidma_video_transaction *trans,
+                          enum axidma_dir dir)
+{
+    int rc, i;
+    size_t image_size;
+    struct axidma_chan *chan;
+    struct scatterlist *sg_list;
+
+    // Setup transmit transfer structure for DMA
+    struct axidma_transfer transfer = {
+        .sg_len = trans->num_frame_buffers,
+        .dir = dir,
+        .type = AXIDMA_VDMA,
+        .wait = false,
+        .channel_id = trans->channel_id,
+        .notify_signal = dev->notify_signal,
+        .process = get_current(),
+        .frame = trans->frame,
+    };
+
+    // Allocate an array to store the scatter list structures for the buffers
+    transfer.sg_list = kmalloc(transfer.sg_len * sizeof(*sg_list), GFP_KERNEL);
+    if (transfer.sg_list == NULL) {
+        axidma_err("Unable to allocate memory for the scatter-gather list.\n");
+        rc = -ENOMEM;
+        goto ret;
+    }
+
+    // For each frame, setup a scatter-gather entry
+    image_size = trans->frame.width * trans->frame.height * trans->frame.depth;
+    for (i = 0; i < transfer.sg_len; i++)
+    {
+        rc = axidma_init_sg_entry(dev, transfer.sg_list, i,
+                                  trans->frame_buffers[i], image_size);
+        if (rc < 0) {
+            goto free_sg_list;
+        }
+    }
+
+    // Get the channel with the given id
+    chan = axidma_get_chan(dev, trans->channel_id);
+    if (chan == NULL && chan->dir != dir &&
+            chan->type != AXIDMA_VDMA) {
+        axidma_err("Invalid device id %d for VDMA %s channel.\n",
+                   trans->channel_id, axidma_dir_to_string(chan->dir));
+        rc = -ENODEV;
+        goto free_sg_list;
+    }
+    transfer.cb_data = &dev->cb_data[trans->channel_id];
+
+    // Prepare the transmit transfer
+    rc = axidma_prep_transfer(chan, &transfer);
+    if (rc < 0) {
+        goto free_sg_list;
+    }
+
+    // Submit the transfer, and immediately return
+    rc = axidma_start_transfer(chan, &transfer);
+
+free_sg_list:
+    kfree(transfer.sg_list);
+ret:
+    return 0;
+}
+
+int axidma_stop_channel(struct axidma_device *dev,
+                        struct axidma_chan *chan_info)
+{
+    struct axidma_chan *chan;
+
+    // Get the transmit and receive channels with the given ids.
+    chan = axidma_get_chan(dev, chan_info->channel_id);
+    if (chan == NULL && chan->type != chan_info->type &&
+            chan->dir != chan_info->dir) {
+        axidma_err("Invalid channel id %d for %s %s channel.\n",
+            chan_info->channel_id, axidma_type_to_string(chan_info->type),
+            axidma_dir_to_string(chan_info->dir));
+        return -ENODEV;
+    }
+
+    // Terminate all DMA transactions on the given channel
+    return dmaengine_terminate_all(chan->chan);
+}
+
+/*----------------------------------------------------------------------------
+ * Initialization and Cleanup
+ *----------------------------------------------------------------------------*/
+
+static int axidma_request_channels(struct platform_device *pdev,
+                                   struct axidma_device *dev)
+{
+    int rc, i;
+    int num_reserved_chans;
+    struct axidma_chan *chan;
+
+    // For each channel, request exclusive access to the channel
+    num_reserved_chans = 0;
+    for (i = 0; i < dev->num_chans; i++)
+    {
+        chan = &dev->channels[i];
+        chan->chan = dma_request_slave_channel(&pdev->dev, chan->name);
+        if (chan->chan == NULL) {
+            axidma_err("Unable to get slave channel %d: %s.\n", i, chan->name);
+            rc = -ENODEV;
+            goto release_channels;
+        }
+        num_reserved_chans += 1;
+    }
+
+    return 0;
+
+release_channels:
+    // Release any channels that have been requested already so far
+    for (i = 0; i < num_reserved_chans; i++)
+    {
+        dma_release_channel(dev->channels[i].chan);
+    }
+    return rc;
+}
+
+int axidma_dma_init(struct platform_device *pdev, struct axidma_device *dev)
+{
+    int rc;
+    size_t elem_size;
+    u64 dma_mask;
+
+    dma_mask = DMA_BIT_MASK(8 * sizeof(dma_addr_t));
+    rc = dma_set_coherent_mask(&dev->pdev->dev, dma_mask);
+    if (rc < 0) {
+        axidma_err("Unable to set the DMA coherent mask.\n");
+        return rc;
+    }
+
+    // Get the number of DMA channels listed in the device tree
+    dev->num_chans = axidma_of_num_channels(pdev);
+    if (dev->num_chans < 0) {
+        return dev->num_chans;
+    }
+
+    // Allocate an array to store all the channel metdata structures
+    elem_size = sizeof(dev->channels[0]);
+    dev->channels = kmalloc(dev->num_chans * elem_size, GFP_KERNEL);
+    if (dev->channels == NULL) {
+        axidma_err("Unable to allocate memory for channel structures.\n");
+        return -ENOMEM;
+    }
+
+    // Allocate an array to store all callback structures, for async
+    elem_size = sizeof(dev->cb_data[0]);
+    dev->cb_data = kmalloc(dev->num_chans * elem_size, GFP_KERNEL);
+    if (dev->cb_data == NULL) {
+        axidma_err("Unable to allocate memory for callback structures.\n");
+        rc = -ENOMEM;
+        goto free_channels;
+    }
+
+    // Parse the type and direction of each DMA channel from the device tree
+    rc = axidma_of_parse_dma_nodes(pdev, dev);
+    if (rc < 0) {
+        return rc;
+    }
+
+    // Exclusively request all of the channels in the device tree entry
+    rc = axidma_request_channels(pdev, dev);
+    if (rc < 0) {
+        goto free_callback_data;
+    }
+
+    axidma_info("DMA: Found %d transmit channels and %d receive channels.\n",
+                dev->num_dma_tx_chans, dev->num_dma_rx_chans);
+    axidma_info("VDMA: Found %d transmit channels and %d receive channels.\n",
+                dev->num_vdma_tx_chans, dev->num_vdma_rx_chans);
+    return 0;
+
+free_callback_data:
+    kfree(dev->cb_data);
+free_channels:
+    kfree(dev->channels);
+    return rc;
+}
+
+void axidma_dma_exit(struct axidma_device *dev)
+{
+    int i;
+    struct dma_chan *chan;
+
+    // Stop all running DMA transactions on all channels, and release
+    for (i = 0; i < dev->num_chans; i++)
+    {
+        chan = dev->channels[i].chan;
+        dmaengine_terminate_all(chan);
+        dma_release_channel(chan);
+    }
+
+    // Free the channel and callback data arrays
+    kfree(dev->channels);
+    kfree(dev->cb_data);
+
+    return;
+}
diff --git a/drivers/staging/xlnx_axidma/axidma_ioctl.h b/drivers/staging/xlnx_axidma/axidma_ioctl.h
new file mode 100644
index 000000000000..9b2309e9e5e6
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axidma_ioctl.h
@@ -0,0 +1,382 @@
+/**
+ * @file axidma_ioctl.h
+ * @date Tuesday, November 24, 2015 at 09:48:17 PM EST
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This file contains the IOCTL interface definition. This is the interface from
+ * userspace to the AXI DMA device to initiate DMA transactions and get
+ * information about AXI DMA devices on the system.
+ **/
+
+#ifndef AXIDMA_IOCTL_H_
+#define AXIDMA_IOCTL_H_
+
+#include <asm/ioctl.h>              // IOCTL macros
+#include <linux/types.h>            // __u* types
+
+/*----------------------------------------------------------------------------
+ * IOCTL Defintions
+ *----------------------------------------------------------------------------*/
+
+// The standard name for the AXI DMA device
+#define AXIDMA_DEV_NAME     "axidma"
+
+// The standard path to the AXI DMA device
+#define AXIDMA_DEV_PATH     ("/dev/" AXIDMA_DEV_NAME)
+
+/*----------------------------------------------------------------------------
+ * IOCTL Argument Definitions
+ *----------------------------------------------------------------------------*/
+
+// Forward declaration of the kernel's DMA channel type (opaque to userspace)
+struct dma_chan;
+
+// Direction from the persepctive of the processor
+/**
+ * Enumeration for direction in a DMA transfer.
+ *
+ * The enumeration has two directions: write is from the processor to the
+ * FPGA, and read is from the FPGA to the processor.
+ **/
+enum axidma_dir {
+    AXIDMA_WRITE,                   ///< Transmits from memory to a device.
+    AXIDMA_READ                     ///< Transmits from a device to memory.
+};
+
+/**
+ * Enumeration for the type of a DMA channel.
+ *
+ * There are two types of channels, the standard DMA channel, and the special
+ * video DMA (VDMA) channel. The VDMA channel is for transferring frame buffers
+ * and other display related data.
+ **/
+enum axidma_type {
+    AXIDMA_DMA,                     ///< Standard AXI DMA engine
+    AXIDMA_VDMA                     ///< Specialized AXI video DMA enginge
+};
+
+/**
+ * Structure representing all of the data about a video frame.
+ *
+ * This has all the information needed to properly setup an AXI VDMA
+ * transaction, which is simply the video dimensions.
+ **/
+struct axidma_video_frame {
+    int height;                     ///< Height of the image in terms of pixels.
+    int width;                      ///< Width of the image in terms of pixels.
+    int depth;                      ///< Depth of the image in terms of pixels.
+};
+
+// TODO: Channel really should not be here
+struct axidma_chan {
+    enum axidma_dir dir;            // The DMA direction of the channel
+    enum axidma_type type;          // The DMA type of the channel
+    int channel_id;                 // The identifier for the device
+    const char *name;               // Name of the channel (ignore)
+    struct dma_chan *chan;          // The DMA channel (ignore)
+    __u64 dma_addr;                 // The address of the DMA device
+};
+
+struct axidma_num_channels {
+    int num_channels;               // Total DMA channels in the system
+    int num_dma_tx_channels;        // DMA transmit channels available
+    int num_dma_rx_channels;        // DMA receive channels available
+    int num_vdma_tx_channels;       // VDMA transmit channels available
+    int num_vdma_rx_channels;       // VDMA receive channels available
+};
+
+struct axidma_channel_info {
+    struct axidma_chan *channels;   // Metadata about all available channels
+};
+
+struct axidma_register_buffer {
+    int fd;                         // Anonymous file descriptor for DMA buffer
+    size_t size;                    // The size of the external DMA buffer
+    void *user_addr;                // User virtual address of the buffer
+};
+
+struct axidma_transaction {
+    bool wait;                      // Indicates if the call is blocking
+    int channel_id;                 // The id of the DMA channel to use
+    void *buf;                      // The buffer used for the transaction
+    size_t buf_len;                 // The length of the buffer
+
+    // Kept as a union for extend ability.
+    union {
+        struct axidma_video_frame frame;    // Frame information for VDMA.
+    };
+};
+
+struct axidma_inout_transaction {
+    bool wait;                      // Indicates if the call is blocking
+    int tx_channel_id;              // The id of the transmit DMA channel
+    void *tx_buf;                   // The buffer containing the data to send
+    size_t tx_buf_len;              // The length of the transmit buffer
+    struct axidma_video_frame tx_frame; // Frame information for transmit.
+    int rx_channel_id;              // The id of the receive DMA channel
+    void *rx_buf;                   // The buffer to place the data in
+    size_t rx_buf_len;              // The length of the receive buffer
+    struct axidma_video_frame rx_frame; // Frame information for receive.
+};
+
+struct axidma_video_transaction {
+    int channel_id;                 // The id of the DMA channel to transmit video
+    int num_frame_buffers;          // The number of frame buffers to use.
+    void **frame_buffers;           // The frame buffer addresses to use for video
+    struct axidma_video_frame frame;        // Information about the frame
+};
+
+/*----------------------------------------------------------------------------
+ * IOCTL Interface
+ *----------------------------------------------------------------------------*/
+
+// The magic number used to distinguish IOCTL's for our device
+#define AXIDMA_IOCTL_MAGIC              'W'
+
+// The number of IOCTL's implemented, used for verification
+#define AXIDMA_NUM_IOCTLS               10
+
+/**
+ * Returns the number of available DMA channels in the system.
+ *
+ * This writes to the structure given as input by the user, telling the
+ * numbers for all DMA channels in the system.
+ *
+ * Outputs:
+ *  - num_channels - The total number of DMA channels in the system.
+ *  - num_dma_tx_channels - The number of transmit AXI DMA channels
+ *  - num_dma_rx_channels - The number of receive AXI DMA channels
+ *  - num_vdma_tx_channels - The number of transmit AXI VDMA channels
+ *  - num_vdma_rx_channels - The number of receive AXI VDMA channels
+ **/
+#define AXIDMA_GET_NUM_DMA_CHANNELS     _IOW(AXIDMA_IOCTL_MAGIC, 0, \
+                                             struct axidma_num_channels)
+
+/**
+ * Returns information on all DMA channels in the system.
+ *
+ * This function writes to the array specified in the pointer given to the
+ * struct structures representing all data about a given DMA channel (device id,
+ * direction, etc.). The array must be able to hold at least the number of
+ * elements returned by AXIDMA_GET_NUM_DMA_CHANNELS.
+ *
+ * The important piece of information returned in the id for the channels.
+ * This, along with the direction and type, uniquely identifies a DMA channel
+ * in the system, and this is how you refer to a channel in later calls.
+ *
+ * Inputs:
+ *  - channels - A pointer to a region of memory that can hold at least
+ *               num_channels * sizeof(struct axidma_chan) bytes.
+ *
+ * Outputs:
+ *  - channels - An array of structures of the following format:
+ *  - An array of structures with the following fields:
+ *       - dir - The direction of the channel (either read or write).
+ *       - type - The type of the channel (either normal DMA or video DMA).
+ *       - channel_id - The integer id for the channel.
+ *       - chan - This field has no meaning and can be safely ignored.
+ **/
+#define AXIDMA_GET_DMA_CHANNELS         _IOR(AXIDMA_IOCTL_MAGIC, 1, \
+                                             struct axidma_channel_info)
+
+/**
+ * Register the given signal to be sent when DMA transactions complete.
+ *
+ * This function sets up an asynchronous signal to be delivered to the invoking
+ * process any DMA subsystem completes a transaction. If the user dispatches
+ * an asynchronous transaction, and wants to know when it completes, they must
+ * register a signal to be delivered.
+ *
+ * The signal must be one of the POSIX real time signals. So, it must be
+ * between the signals SIGRTMIN and SIGRTMAX. The kernel will deliver the
+ * channel id back to the userspace signal handler.
+ *
+ * This can be used to have a user callback function, effectively emulating an
+ * interrupt in userspace. The user must register their signal handler for
+ * the specified signal for this to happen.
+ *
+ * Inputs:
+ *  - signal - The signal to send upon transaction completion.
+ **/
+#define AXIDMA_SET_DMA_SIGNAL           _IO(AXIDMA_IOCTL_MAGIC, 2)
+
+/**
+ * Registers the external DMA buffer with the driver, making it available to be
+ * used in DMA transfers.
+ *
+ * Sometimes, it may be useful to use a DMA buffer that was allocated by another
+ * driver. The best example of this is if you want to interact with a
+ * frame buffer allocated by a DRM driver.
+ *
+ * However, the driver cannot simply access this DMA buffer as is. The user must
+ * register the buffer with the driver, so that it can get the information from
+ * the driver that originally allocated it.
+ *
+ * This uses the kernel's DMA buffer sharing API. Thus, the user must first tell
+ * the other driver to export the DMA buffer for sharing, typically done through
+ * an IOCTL. This will return a file descriptor, which the user must pass into
+ * this function, along with the virtual address in userspace.
+ *
+ * Inputs:
+ *  - fd - File descriptor corresponding to the DMA buffer share.
+ *  - size - The size of the DMA buffer in bytes.
+ *  - user_addr - The user virtual address of the buffer.
+ **/
+#define AXIDMA_REGISTER_BUFFER          _IOR(AXIDMA_IOCTL_MAGIC, 3, \
+                                             struct axidma_register_buffer)
+
+/**
+ * Receives the data from the logic fabric into the processing system.
+ *
+ * This function receives data from a device on the PL fabric through
+ * AXI DMA into memory. The device id should be an id that is returned by the
+ * get dma channels ioctl. The user can specify if the call should wait for the
+ * transfer to complete, or if it should return immediately.
+ *
+ * The specified buffer must be within an address range that was allocated by a
+ * call to mmap with the AXI DMA device. Also, the buffer must be able to hold
+ * at least `buf_len` bytes.
+ *
+ * Inputs:
+ *  - wait - Indicates if the call should be blocking or non-blocking
+ *  - channel_id - The id for the channel you want receive data over.
+ *  - buf - The address of the buffer you want to receive the data in.
+ *  - buf_len - The number of bytes to receive.
+ **/
+#define AXIDMA_DMA_READ                 _IOR(AXIDMA_IOCTL_MAGIC, 4, \
+                                             struct axidma_transaction)
+
+/**
+ * Sends the given data from the processing system to the logic fabric.
+ *
+ * This function sends data from memory to a device on the PL fabric through
+ * AXI DMA. The device id should be an id that is returned by the get dma
+ * channels ioctl. The user can specify if the call should wait for the transfer
+ * to complete, or if it should return immediately.
+ *
+ * The specified buffer must be within an address range that was allocated by a
+ * call to mmap with the AXI DMA device. Also, the buffer must be able to hold
+ * at least `buf_len` bytes.
+ *
+ * Inputs:
+ *  - wait - Indicates if the call should be blocking or non-blocking
+ *  - channel_id - The id for the channel you want to send data over.
+ *  - buf - The address of the data you want to send.
+ *  - buf_len - The number of bytes to send.
+ **/
+#define AXIDMA_DMA_WRITE                _IOR(AXIDMA_IOCTL_MAGIC, 5, \
+                                             struct axidma_transaction)
+
+/**
+ * Performs a two-way transfer between the logic fabric and processing system.
+ *
+ * This function both sends data to the PL and receives data from the PL fabric.
+ * It is intended for DMA transfers that are tightly coupled together
+ * (e.g. converting an image to grayscale on the PL fabric). The device id's for
+ * both channels should be ones that are returned by the get dma ioctl. The user
+ * can specify if the call should block. If it blocks, it will wait until the
+ * receive transaction completes.
+ *
+ * The specified buffers must be within an address range that was allocated by a
+ * call to mmap with the AXI DMA device. Also, each buffer must be able to hold
+ * at least the number of bytes that are being transfered.
+ *
+ * Inputs:
+ *  - wait - Indicates if the call should be blocking or non-blocking
+ *  - tx_channel_id - The id for the channel you want transmit data on.
+ *  - tx_buf - The address of the data you want to send.
+ *  - tx_buf_len - The number of bytes you want to send.
+ *  - rx_buf - The address of the buffer you want to receive data in.
+ *  - rx_buf_len - The number of bytes you want to receive.
+ **/
+#define AXIDMA_DMA_READWRITE            _IOR(AXIDMA_IOCTL_MAGIC, 6, \
+                                             struct axidma_inout_transaction)
+
+/**
+ * Performs frame-buffer based transfers from a camera on the fabric.
+ *
+ * This function performs a video transfer from the logic fabric. It receives
+ * the given buffers from logic fabric (intended for a camera pipeline). When it
+ * reaches the end of the buffers, it loops back and receives the data again in
+ * the first buffer. This is used for frame-buffer based cameras.
+ *
+ * All of the frame buffers must be within an address range that was allocated
+ * by a call to mmap with the AXI DMA device. Also, each buffer must
+ * be able to hold a frame of (width * height * depth) bytes. The input array of
+ * buffers must be a memory location that holds `num_frame_buffers` addresses.
+ *
+ * This call is always non-blocking as the VDMA engine will run forever. In
+ * order to end the transaction, you must make a call to the stop dma channel
+ * ioctl.
+ *
+ * Inputs:
+ *  - channel_id - The id for the channel you want to send data over.
+ *  - num_frame_buffers - The number of frame buffers you're using.
+ *  - frame_buffers - An array of the frame buffer addresses.
+ *  - width - The width of the frame (image) in pixels.
+ *  - height - The height of the frame in lines.
+ *  - depth - The size of each pixel in the frame in bytes.
+ **/
+#define AXIDMA_DMA_VIDEO_READ           _IOR(AXIDMA_IOCTL_MAGIC, 7, \
+                                             struct axidma_video_transaction)
+
+/**
+ * Performs frame-buffer based transfers to a display on the logic fabric.
+ *
+ * This function performs a video transfer to the logic fabric. It sends
+ * the given buffers to logic fabric (intended for a display pipeline). When it
+ * reaches the end of the buffers, it loops back and re-sends the first buffer.
+ * This is used for frame-buffer based graphics.
+ *
+ * All of the frame buffers must be within an address range that was allocated
+ * by a call to mmap with the AXI DMA device. Also, each buffer must
+ * be able to hold a frame of (width * height * depth) bytes. The input array of
+ * buffers must be a memory location that holds `num_frame_buffers` addresses.
+ *
+ * This call is always non-blocking as the VDMA engine will run forever. In
+ * order to end the transaction, you must make a call to the stop dma channel
+ * ioctl.
+ *
+ * Inputs:
+ *  - channel_id - The id for the channel you want to send data over.
+ *  - num_frame_buffers - The number of frame buffers you're using.
+ *  - frame_buffers - An array of the frame buffer addresses.
+ *  - width - The width of the frame (image) in pixels.
+ *  - height - The height of the frame in lines.
+ *  - depth - The size of each pixel in the frame in bytes.
+ **/
+#define AXIDMA_DMA_VIDEO_WRITE          _IOR(AXIDMA_IOCTL_MAGIC, 8, \
+                                             struct axidma_video_transaction)
+
+/**
+ * Stops all transactions on the given DMA channel.
+ *
+ * This function flushes all in-progress transactions, and discards all pending
+ * transactions on the given DMA channel. The specified id should be one that
+ * was returned by the get dma channels ioctl.
+ *
+ * Inputs:
+ *  - dir - The direction of the channel (either read or write).
+ *  - type - The type of the channel (either normal DMA or video DMA).
+ *  - channel_id - The integer id for the channel.
+ *  - chan - This field is unused an can be safely left uninitialized.
+ */
+#define AXIDMA_STOP_DMA_CHANNEL         _IOR(AXIDMA_IOCTL_MAGIC, 9, \
+                                             struct axidma_chan)
+
+/**
+ * Unregisters and external DMA buffer previously registered through an
+ * AXIDMA_REGISTER_BUFFER IOCTL
+ *
+ * All external buffers that are registered by the user must be freed in order
+ * to ensure that all kernel data structures are properly cleaned up. This
+ * removes the external DMA buffer from the driver, so it can no longer be
+ * used in DMA transfers after this call.
+ *
+ * Inputs:
+ *  - user_addr - The user virtual address of the external DMA buffer.
+ **/
+#define AXIDMA_UNREGISTER_BUFFER        _IO(AXIDMA_IOCTL_MAGIC, 10)
+
+#endif /* AXIDMA_IOCTL_H_ */
diff --git a/drivers/staging/xlnx_axidma/axidma_of.c b/drivers/staging/xlnx_axidma/axidma_of.c
new file mode 100644
index 000000000000..ef177cb02774
--- /dev/null
+++ b/drivers/staging/xlnx_axidma/axidma_of.c
@@ -0,0 +1,271 @@
+/**
+ * @file axidma_of.c
+ * @date Wednesday, April 13, 2016 at 10:59:45 AM EDT
+ * @author Brandon Perez (bmperez)
+ * @author Jared Choi (jaewonch)
+ *
+ * This file contains functions for parsing the relevant device tree entries for
+ * the DMA engines that are used.
+ *
+ * @bug No known bugs.
+ **/
+
+// Kernel Dependencies
+#include <linux/of.h>               // Device tree parsing functions
+#include <linux/of_address.h>       // Device tree memory parsing functions
+#include <linux/platform_device.h>  // Platform device definitions
+
+// Local Dependencies
+#include "axidma.h"                 // Internal Definitions
+
+/*----------------------------------------------------------------------------
+ * Internal Helper Functions
+ *----------------------------------------------------------------------------*/
+
+static int axidma_parse_compatible_property(struct device_node *dma_chan_node,
+        struct axidma_chan *chan, struct axidma_device *dev)
+{
+    struct device_node *np;
+
+    // Shorten the name for the dma_chan_node
+    np = dma_chan_node;
+
+    // Determine if the channel is DMA or VDMA, and if it is transmit or receive
+    if (of_device_is_compatible(np, "xlnx,axi-dma-mm2s-channel") > 0) {
+        chan->type = AXIDMA_DMA;
+        chan->dir = AXIDMA_WRITE;
+        dev->num_dma_tx_chans += 1;
+    } else if (of_device_is_compatible(np, "xlnx,axi-dma-s2mm-channel") > 0) {
+        chan->type = AXIDMA_DMA;
+        chan->dir = AXIDMA_READ;
+        dev->num_dma_rx_chans += 1;
+    } else if (of_device_is_compatible(np, "xlnx,axi-vdma-mm2s-channel") > 0) {
+        chan->type = AXIDMA_VDMA;
+        chan->dir = AXIDMA_WRITE;
+        dev->num_vdma_tx_chans += 1;
+    } else if (of_device_is_compatible(np, "xlnx,axi-vdma-s2mm-channel") > 0) {
+        chan->type = AXIDMA_VDMA;
+        chan->dir = AXIDMA_READ;
+        dev->num_vdma_rx_chans += 1;
+    } else if (of_find_property(np, "compatible", NULL) == NULL) {
+        axidma_node_err(np, "DMA channel lacks 'compatible' property.\n");
+    } else {
+        axidma_node_err(np, "DMA channel has an invalid 'compatible' "
+                        "property.\n");
+        axidma_err("The 'compatible' property must be one of: {"
+                   "xlnx,axi-dma-mm2s-channel, xlnx,axi-dma-mm2s-channel, "
+                   "xlnx,axi-dma-mm2s-channel, xlnx,axi-dma-mm2s-channel}.\n");
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int axidma_of_parse_dma_name(struct device_node *driver_node, int index,
+                                    struct axidma_chan *chan)
+{
+    int rc;
+
+    // Parse the index'th dma name from the 'dma-names' property
+    rc = of_property_read_string_index(driver_node, "dma-names", index,
+                                       &chan->name);
+    if (rc < 0) {
+        axidma_node_err(driver_node, "Unable to read DMA name %d from the "
+                        "'dma-names' property.\n", index);
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+static int axidma_of_parse_channel(struct device_node *dma_node, int channel,
+        struct axidma_chan *chan, struct axidma_device *dev)
+{
+    int rc;
+    struct device_node *dma_chan_node;
+    struct resource dma_res;
+    u32 channel_id;
+
+    // Verify that the DMA node has two channel (child) nodes, one for TX and RX
+    if (of_get_child_count(dma_node) < 1) {
+        axidma_node_err(dma_node, "DMA does not have any channel nodes.\n");
+        return -EINVAL;
+    } else if (of_get_child_count(dma_node) > 2) {
+        axidma_node_err(dma_node, "DMA has more than two channel nodes.\n");
+        return -EINVAL;
+    }
+
+    // Go to the child node that we're parsing
+    dma_chan_node = of_get_next_child(dma_node, NULL);
+    if (channel == 1) {
+        dma_chan_node = of_get_next_child(dma_node, dma_chan_node);
+    }
+
+    // Check if the specified node exists
+    if (dma_chan_node == NULL) {
+        axidma_node_err(dma_chan_node, "Unable to find child node number %d.\n",
+                channel);
+    }
+
+    // Read out the channel's unique device id, and put it in the structure
+    if (of_find_property(dma_chan_node, "xlnx,device-id", NULL) == NULL) {
+        axidma_node_err(dma_chan_node, "DMA channel is missing the "
+                        "'xlnx,device-id' property.\n");
+        return -EINVAL;
+    }
+    rc = of_property_read_u32(dma_chan_node, "xlnx,device-id", &channel_id);
+    if (rc < 0) {
+        axidma_err("Unable to read the 'xlnx,device-id' property.\n");
+        return -EINVAL;
+    }
+    chan->channel_id = channel_id;
+
+    rc = of_address_to_resource(dma_node, 0, &dma_res);
+    if (rc) {
+        axidma_err("Unable to read the memory resource for the dma node.\n");
+        return -EINVAL;
+    }
+    chan->dma_addr = dma_res.start;
+
+    // Use the compatible string to determine the channel's information
+    rc = axidma_parse_compatible_property(dma_chan_node, chan, dev);
+    if (rc < 0) {
+        return rc;
+    }
+
+    return 0;
+}
+
+static int axidma_check_unique_ids(struct axidma_device *dev)
+{
+    int i, j;
+    struct axidma_chan *chan1, *chan2;
+
+    // For each channel, check that its ID does not match any other channel's
+    for (i = 0; i < dev->num_chans; i++)
+    {
+        chan1 = &dev->channels[i];
+        for (j = i+1; j < dev->num_chans; j++)
+        {
+            chan2 = &dev->channels[j];
+            if (chan1->channel_id == chan2->channel_id) {
+                axidma_err("Channels %d and %d in the 'dmas' list have the "
+                           "same channel id.\n", i, j);
+                return -EINVAL;
+            }
+        }
+    }
+
+    return 0;
+}
+
+/*----------------------------------------------------------------------------
+ * Public Interface
+ *----------------------------------------------------------------------------*/
+
+int axidma_of_num_channels(struct platform_device *pdev)
+{
+    int num_dmas, num_dma_names;
+    struct device_node *driver_node;
+
+    // Get the device tree node for the driver
+    driver_node = pdev->dev.of_node;
+
+    // Check that the device tree node has the 'dmas' and 'dma-names' properties
+    if (of_find_property(driver_node, "dma-names", NULL) == NULL) {
+        axidma_node_err(driver_node, "Property 'dma-names' is missing.\n");
+        return -EINVAL;
+    } else if (of_find_property(driver_node, "dmas", NULL) == NULL) {
+        axidma_node_err(driver_node, "Property 'dmas' is missing.\n");
+        return -EINVAL;
+    }
+
+    // Get the length of the properties, and make sure they are not empty
+    num_dma_names = of_property_count_strings(driver_node, "dma-names");
+    if (num_dma_names < 0) {
+        axidma_node_err(driver_node, "Unable to get the 'dma-names' property "
+                        "length.\n");
+        return -EINVAL;
+    } else if (num_dma_names == 0) {
+        axidma_node_err(driver_node, "'dma-names' property is empty.\n");
+        return -EINVAL;
+    }
+    num_dmas = of_count_phandle_with_args(driver_node, "dmas", "#dma-cells");
+    if (num_dmas < 0) {
+        axidma_node_err(driver_node, "Unable to get the 'dmas' property "
+                        "length.\n");
+        return -EINVAL;
+    } else if (num_dmas == 0) {
+        axidma_node_err(driver_node, "'dmas' property is empty.\n");
+        return -EINVAL;
+    }
+
+    // Check that the number of entries in each property matches
+    if (num_dma_names != num_dmas) {
+        axidma_node_err(driver_node, "Length of 'dma-names' and 'dmas' "
+                        "properties differ.\n");
+        return -EINVAL;
+    }
+
+    return num_dma_names;
+}
+
+int axidma_of_parse_dma_nodes(struct platform_device *pdev,
+                              struct axidma_device *dev)
+{
+    int i, rc;
+    int channel;
+    struct of_phandle_args phandle_args;
+    struct device_node *driver_node, *dma_node;
+
+    // Get the device tree node for the driver
+    driver_node = pdev->dev.of_node;
+
+    // Initialize the channel type counts
+    dev->num_dma_tx_chans = 0;
+    dev->num_dma_rx_chans = 0;
+    dev->num_vdma_tx_chans = 0;
+    dev->num_vdma_rx_chans = 0;
+
+    /* For each DMA channel specified in the deivce tree, parse out the
+     * information about the channel, namely its direction and type. */
+    for (i = 0; i < dev->num_chans; i++)
+    {
+        // Get the phanlde to the DMA channel
+        rc = of_parse_phandle_with_args(driver_node, "dmas", "#dma-cells", i,
+                                        &phandle_args);
+        if (rc < 0) {
+            axidma_node_err(driver_node, "Unable to get phandle %d from the "
+                            "'dmas' property.\n", i);
+            return rc;
+        }
+
+        // Check that the phandle has the expected arguments
+        dma_node = phandle_args.np;
+        channel = phandle_args.args[0];
+        if (phandle_args.args_count < 1) {
+            axidma_node_err(driver_node, "Phandle %d in the 'dmas' property is "
+                            "is missing the channel direciton argument.\n", i);
+            return -EINVAL;
+        } else if (channel != 0 && channel != 1) {
+            axidma_node_err(driver_node, "Phandle %d in the 'dmas' property "
+                            "has an invalid channel (argument 0).\n", i);
+            return -EINVAL;
+        }
+
+        // Parse out the information about the channel
+        rc = axidma_of_parse_channel(dma_node, channel, &dev->channels[i], dev);
+        if (rc < 0) {
+            return rc;
+        }
+
+        // Parse the name of the channel
+        rc = axidma_of_parse_dma_name(driver_node, i, &dev->channels[i]);
+        if (rc < 0) {
+            return rc;
+        }
+    }
+
+    // Check that all channels have unique channel ID's
+    return axidma_check_unique_ids(dev);
+}
-- 
2.17.1
